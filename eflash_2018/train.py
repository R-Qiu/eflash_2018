import argparse
import matplotlib
import numpy as np
import pickle
matplotlib.use('Qt5Agg')
import numpy as np
import h5py
import json
import os
import sys
from sklearn.ensemble import RandomForestClassifier
from sklearn.decomposition import PCA
from PyQt5 import QtCore, QtWidgets, QtGui
from PyQt5.QtWidgets import QShortcut
from PyQt5.QtGui import QKeySequence
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--patch-file",
                        required=True,
                        help="The patch file generated by collect-patches")
    parser.add_argument("--output",
                        required=True,
                        help="The random forest model's pickle file")
    return parser.parse_args()


class MPLCanvas(FigureCanvas):
    def __init__(self, parent):
        figure = Figure()
        self.axes = figure.add_subplot(1, 1, 1)
        super(MPLCanvas, self).__init__(figure)
        self.setParent(parent)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,
                           QtWidgets.QSizePolicy.Expanding)
        self.updateGeometry()

    def show(self, image):
        self.axes.cla()
        self.axes.imshow(image, interpolation='bicubic')
        self.draw()


class ApplicationWindow(QtWidgets.QMainWindow):
    def __init__(self, patches, x, y, z, output_file):
        QtWidgets.QMainWindow.__init__(self)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.setWindowTitle("Train")

        self.file_menu = QtWidgets.QMenu('&File', self)
        self.file_menu.addAction("&Save", self.fileSave)
        self.file_menu.addAction("&Write coordinates",
                                 self.fileWriteCoordinates)
        self.file_menu.addAction("&Train", self.fileTrain)
        self.file_menu.addAction('&Quit', self.fileQuit,
                                 QtCore.Qt.CTRL + QtCore.Qt.Key_Q)
        self.menuBar().addMenu(self.file_menu)
        self.save_shortcut = QShortcut(QKeySequence("Ctrl+S"), self)
        self.save_shortcut.activated.connect(self.fileSave)
        self.train_shortcut = QShortcut(QKeySequence("T"), self)
        self.train_shortcut.activated.connect(self.fileTrain)

        self.image_menu = QtWidgets.QMenu("&Image", self)
        self.image_menu.addAction("Ne&xt", self.imageNext)
        self.image_menu.addAction("Next &Positive", self.imageNextPositive)
        self.image_menu.addAction("Next &Negative", self.imageNextNegative)
        self.image_menu.addAction("Next &Unsure", self.imageNextUnsure)
        self.menuBar().addMenu(self.image_menu)
        self.next_shortcut = QShortcut(QKeySequence("X"), self)
        self.next_shortcut.activated.connect(self.imageNext)
        self.next_positive_shortcut = QShortcut(QKeySequence("Ctrl+P"), self)
        self.next_positive_shortcut.activated.connect(self.imageNextPositive)
        self.next_negative_shortcut = QShortcut(QKeySequence("Ctrl+N"), self)
        self.next_negative_shortcut.activated.connect(self.imageNextNegative)
        self.next_unsure_shortcut = QShortcut(QKeySequence("U"), self)
        self.next_unsure_shortcut.activated.connect(self.imageNextUnsure)

        self.mark_menu = QtWidgets.QMenu("&Mark", self)
        self.mark_menu.addAction("&Positive", self.markPositive)
        self.mark_menu.addAction("&Negative", self.markNegative)
        self.menuBar().addMenu(self.mark_menu)

        self.main_widget = QtWidgets.QWidget(self)

        l = QtWidgets.QVBoxLayout(self.main_widget)
        self.canvas = MPLCanvas(self.main_widget)
        l.addWidget(self.canvas)

        self.main_widget.setFocus()
        self.setCentralWidget(self.main_widget)

        self.patches = patches
        self.x, self.y, self.z = x, y, z
        self.output_file = output_file
        if os.path.exists(self.output_file):
            with open(self.output_file, "rb") as fd:
                d = pickle.load(fd)
                self.pca = d["pca"]
                self.classifier = d["classifier"]
                self.marks = d["marks"]
                if "predictions" in d:
                    self.predictions = d["predictions"]
                if "pred_probs" in d:
                    self.pred_probs = d["pred_probs"]
        else:
            self.marks = np.zeros(len(patches), np.int8)
            self.classifier = None
            self.pca = PCA(n_components=24)
        self.pca_features = self.pca.fit_transform(
            patches.reshape((len(patches), np.prod(patches.shape[1:]))))
        self.imageNext()


    def fileQuit(self):
        self.close()

    def closeEvent(self, ce):
        self.fileQuit()

    def fileSave(self):
        self.statusBar().showMessage("Saving...")
        object = dict(pca=self.pca,
                      classifier=self.classifier,
                      marks=self.marks,
                      predictions=self.predictions,
                      pred_probs=self.pred_probs)
        with open(self.output_file, "wb") as fd:
            pickle.dump(object, fd)
        self.statusBar().showMessage("Saved to %s" % self.output_file)

    def fileWriteCoordinates(self):
        """Write a coordinates file using the current positives.

        """
        if self.classifier == None:
            self.statusBar().showMessage("Please train your model")
            return
        mask = self.predictions == 1
        coords = np.column_stack((self.x[mask], self.y[mask], self.z[mask]))
        filename, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, "Save coordinates",
            filter="Coordinates (*.json);;All files (*)"
        )
        if filename:
            with open(filename, "w") as fd:
                json.dump(coords.tolist(), fd)

    def fileTrain(self):
        self.statusBar().showMessage("Training...")
        self.classifier = RandomForestClassifier(
            n_estimators=256,
            class_weight="balanced_subsample")
        mask = self.marks != 0
        self.classifier.fit(self.pca_features[mask],
                            (self.marks[mask] + 1) // 2)
        self.statusBar().showMessage("Predicting...")
        self.predictions = self.classifier.predict(self.pca_features)
        self.pred_probs = self.classifier.predict_proba(self.pca_features)
        self.statusBar().showMessage("Training complete")

    def imageNext(self):
        mask = np.where(self.marks == 0)[0]
        self.pick(mask)

    def pick(self, mask):
        self.idx = mask[np.random.randint(0, len(mask))]
        self.canvas.show(self.patches[self.idx])

    def imageNextPositive(self):
        if self.classifier is None:
            self.statusBar().showMessage(
                "Hey, how about training a classifier with the \"T\" key?")
            return
        mask = np.where((self.marks == 0) &
                        (self.predictions == 1))[0]
        self.pick(mask)

    def imageNextNegative(self):
        if self.classifier is None:
            self.statusBar().showMessage(
                "Hey, how about training a classifier with the \"T\" key?")
            return
        mask = np.where((self.marks == 0) &
                        (self.predictions == 0))[0]
        self.pick(mask)

    def imageNextUnsure(self):
        if self.classifier is None:
            self.statusBar().showMessage(
                "Hey, how about training a classifier with the \"T\" key?")
            return
        unmarked = np.where(self.marks == 0)[0]
        order = np.argsort(np.abs(self.pred_probs[unmarked, 0] - .5))
        idx = np.random.randint(0, min(len(order), max(len(order) // 100, 10 )))
        self.idx = unmarked[order[idx]]
        self.canvas.show(self.patches[self.idx])

    def markPositive(self):
        self.marks[self.idx] = 1

    def markNegative(self):
        self.marks[self.idx] = -1


def main():
    app = QtWidgets.QApplication(sys.argv)
    args = parse_args()
    with h5py.File(args.patch_file, "r") as fd:
        patches = fd["patches"][:]
        x = fd["x"][:]
        y = fd["y"][:]
        z = fd["z"][:]
    window = ApplicationWindow(patches, x, y, z, args.output)
    window.setWindowTitle("Train")
    window.show()
    sys.exit(app.exec())

if __name__=="__main__":
    main()